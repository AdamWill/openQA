#!/usr/bin/env perl
use strict;
use warnings;
use 5.010;

use YAML::PP;
use Data::Dumper;
use Mojo::File qw(path);
use Getopt::Long;
use Module::CoreList;
use FindBin qw($Bin $Script);

GetOptions(
    "help|h" => \my $help,
    "check-ci" => \my $ci,
);

usage(0) if $help;

my $scriptname   = __FILE__;
my $yamlfile     = "dependencies.yaml";
my $file         = "$Bin/../$yamlfile";
my $specfile     = "$Bin/../openQA.spec";
my $cpanfile     = "$Bin/../cpanfile";
my $circlecifile = "$Bin/../.circleci/dependencies.txt";

my $data     = YAML::PP->new->load_file($file);
my $spec     = path($specfile)->slurp;
my $circleci = path($circlecifile)->slurp;

my @spectargets = qw(assetpack build client common       devel main test worker);
my @cpantargets = qw(assetpack       client common cover devel main test worker);

my ($modules, $test_modules, $cover_modules, $devel_modules) = get_modules();

if ($ci) {
    check_ci({ %$modules, %$test_modules, %$cover_modules });
}
else {
    update_spec();
    update_cpanfile($modules, $test_modules, $cover_modules, $devel_modules);
}

sub update_spec {

    for my $target (@spectargets) {
        my $deps     = $data->{$target . '_requires'};
        my $prefix   = "%define ${target}_requires";
        my $specline = $prefix;
        for my $key (sort keys %$deps) {
            my $version = $deps->{$key};
            if (ref $version) {
                $version = $version->{rpm};
            }
            $specline .= " $key";
            if ($key eq 'perl(Perl::Tidy)') {
                undef $version;
            }
            if ($version) {
                $specline .= " $version";
            }
        }
        my $comment = "# The following line is generated from $yamlfile";
        if ($spec =~ s/^# .*generated.*\n^$prefix.*/$comment\n$specline/m) {
            next;
        }
        # No comment above the line yet
        unless ($spec =~ s/^$prefix.*/$comment\n$specline/m) {
            die "/^$prefix/ not found in $specfile";
        }
    }

    path($specfile)->spurt($spec);
    say "Updated $specfile";
}

sub get_modules {

    my (%modules, %test, %cover, %devel);
    for my $target (@cpantargets) {
        my $deps = $data->{$target . '_requires'};
        for my $key (keys %$deps) {
            my $module = $key;
            next unless $module =~ s/^perl\((.*)\)$/$1/;
            my $version = $deps->{$key};
            if (ref $version) {
                $version = $version->{perl};
            }
            if ($target eq 'test') {
                $test{$module} = $version;
            }
            elsif ($target eq 'cover') {
                $cover{$module} = $version;
            }
            elsif ($target eq 'devel') {
                $devel{$module} = $version;
            }
            else {
                $modules{$module} = $version;
            }
        }
    }
    return (\%modules, \%test, \%cover, \%devel);
}

sub _requires_line {
    # requires 'Archive::Extract', '> 0.7';
    my ($hash, $module) = @_;
    my $version = $hash->{$module};
    my $line    = "requires '$module'";
    $line .= qq{, '$version'} if $version;
    $line .= ";\n";
    return $line;
}

sub update_cpanfile {
    my ($modules, $test, $cover, $devel) = @_;
    my $cpan = <<"EOM";
##################################################
# WARNING
# This file is autogenerated by $scriptname
# from $yamlfile
##################################################

EOM
    for my $module (sort keys %$modules) {
        $cpan .= _requires_line($modules, $module);
    }
    my $test_requires = '';
    for my $module (sort keys %$test) {
        $test_requires .= '    ' . _requires_line($test, $module);
    }
    my $cover_requires = '';
    for my $module (sort keys %$cover) {
        $cover_requires .= '    ' . _requires_line($cover, $module);
    }
    my $devel_requires = '';
    for my $module (sort keys %$devel) {
        $devel_requires .= '    ' . _requires_line($devel, $module);
    }
    $cpan .= <<"EOM";

on 'test' => sub {
$test_requires
};

on 'devel' => sub {
$devel_requires
};

feature 'coverage', 'coverage for CI' => sub {
$cover_requires
};
EOM

    path($cpanfile)->spurt($cpan);
    say "Updated $cpanfile";
}

sub check_ci {
    my ($modules) = @_;
    my %modules = %$modules;
    my %circleci = map { m/^(.*)-([\d.]+)$/ ? ($1 => $2) : () } split m/\r?\n/, $circleci;
    for my $module (keys %modules) {
        next if Module::CoreList::removed_from($module); # not in core anymore
        my $version = $modules{$module};
        $version =~ s/^(==|>=|<=|>) // if $version;
        my $first_release = Module::CoreList::first_release($module, $version);
        next unless $first_release;
        my $iscore = $first_release <= 5.010000;
        next unless $iscore;
        delete $modules{ $module };
    }
    my $args = join ' ', map { "'perl($_)'" } sort keys %modules;
    my $cmd = "zypper search --provides $args";
    my @out = qx{$cmd};
    while (@out and $out[0] !~ m/^---\+/) {
        shift @out;
    }
    shift @out;
    @out = sort map { m/\| *(\S+) / ? $1 : () } @out;
    @out = grep {
        not m/^(?:perl|perl-32bit|perl-base|perl-base-32bit|apache2-mod_perl)$/;
    } @out;
    my @missing;
    for my $package (@out) {
        unless ($circleci{ $package }) {
            push @missing, $package;
        }
        delete $circleci{ $package };
    }
    say "Packages missing in $circlecifile:";
    say for @missing;
    say "Leftover packages in $circlecifile:";
    for my $package (sort keys %circleci) {
        next unless $package =~ m/^perl-/;
        say $package;
    }


}

sub usage {
    my ($exit) = @_;
    print <<"EOM";
Usage:
    # update cpanfile and openQA.spec
    $0
    # [Experimental] Compare deps with .circleci/dependencies.txt
    $0 --check-ci
EOM
    exit $exit;
}
