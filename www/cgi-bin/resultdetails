#!/usr/bin/perl -w
use strict;
use CGI ":standard";
use lib "/srv/www/cgi-bin/modules";
use openqa;
use Text::MicroTemplate "encoded_string";
use Text::MicroTemplate::Extended;

my $testname=$ENV{PATH_INFO};
if(!defined $testname) { print header(-status=>404)."must specify result file as path"; exit 0 }
$testname=~s%^/%%;
if($testname=~/(?:\.\.)|[^a-zA-Z0-9._+-]/){ print header(-status=>"403 Forbidden")."Forbidden: invalid path"; exit 0 }
$testname=~s/\.autoinst\.txt$//; $testname=~s/\.ogv$//; # be tolerant in what we accept
my $imgdir=openqa::imgdir($testname);
my $fqfn="$basedir/$prj/video/$testname.ogv.autoinst.txt";
if(!-e $fqfn) { print header(-status=>404)."file not found"; exit 0 }

my @lines=parse_log($fqfn);
my @timeouts=<$imgdir/timeout-[0-9]*.ppm*>;
if(@timeouts) {unshift(@lines, ["timeout","not-autochecked"])}
my @modlist=();
foreach my $entry (@lines) {
	my ($name,$result) = @$entry;
	my ($imgresultstring,$wavresultstring,$ocrresultstring) = ($result,$result,$result);
	if ($imgresultstring=~/\(.+\)/) { $imgresultstring=~s{.*\((.*)\).*}{$1}; }
	else { $imgresultstring=''; }
	if ($wavresultstring=~/\[.+\]/) { $wavresultstring=~s{.*\[(.*)\].*}{$1}; }
	else { $wavresultstring=''; }
	if ($ocrresultstring=~/\{.+\}/) { $ocrresultstring=~s{.*\{(.*)\}.*}{$1}; }
	else { $ocrresultstring=''; }
	my @imgresults=split(/,/, $imgresultstring);
	my @wavresults=split(/,/, $wavresultstring);
	my @ocrresults=split(/,/, $ocrresultstring);
	# add link to $imgdir/$name*.ppm via png CGI
	my @imglist;
	foreach my $imgpath (<$imgdir/$name-[0-9]*.ppm*>) {
		my $imgres = (@imgresults)?$imgresults[scalar(@imglist)]:'na';
		if($imgres eq "na") { $imgres=(@ocrresults)?$ocrresults[scalar(@imglist)]:'na';}
		$imgpath=data_name($imgpath);
		push(@imglist, {name => $imgpath, result => $imgres});
	}
	# add link to $imgdir/$name*.wav via ogg CGI
	my @wavlist;
	foreach my $wavpath (<$imgdir/$name-[0-9]*.wav>) {
		my $wavres = (@wavresults)?$wavresults[scalar(@wavlist)]:'na';
		$wavpath=data_name($wavpath);
		push(@wavlist, {name => $wavpath, result => $wavres});
	}
	# add link to $imgdir/$name*.txt as direct link
	my @ocrlist;
	foreach my $ocrpath (<$imgdir/$name-[0-9]*.txt>) {
		$ocrpath=data_name($ocrpath);
		my $ocrscreenshotid = $ocrpath;
		$ocrscreenshotid=~s/^\w+-(\d+)/$1/;
		my $ocrres = (@ocrresults)?$ocrresults[--$ocrscreenshotid]:'na';
		push(@ocrlist, {name => $ocrpath, result => $ocrres});
	}

	($result)=split(/ /, $result); #~s{(.+) .*}{$1};
	my $image = (get_testimgs($name))?1:0;
	my $sound = (get_testwavs($name))?1:0;
	my $ocr = (@ocrresults)?1:0;
	push(@modlist, {name => $name, result => $result, screenshots => \@imglist, wavs => \@wavlist, ocrs => \@ocrlist, refimg => $image, audio => $sound, ocr => $ocr});
}

my $backlogpath = back_log($testname);
my $diskimg = 0;
if(-e "$backlogpath/l1") {
	if((stat("$backlogpath/l1"))[12] && !((stat("$backlogpath/l2"))[12])) { # skip raid
		$diskimg = 1;
	}
}

my $mt = Text::MicroTemplate::Extended->new(
	include_path  => ['../htdocs/template'],
	template_args => { modlist => \@modlist, testname => $testname, diskimg => $diskimg },
);

print header(-charset=>"UTF-8", -type=>"text/html");
print $mt->render('resultdetails');
