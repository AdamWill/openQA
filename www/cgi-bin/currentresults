#!/usr/bin/perl -w
use strict;
use CGI ":standard";
use FindBin;
use lib "$FindBin::Bin/modules";
use awstandard;
use sort_list;
use openqa;
use Text::MicroTemplate "encoded_string";
use Text::MicroTemplate::Extended;

my $defaulthoursfresh=4*24;

my %options;
for my $p (qw'sort hours ib match ob') {
	$options{$p}=param($p);
}
if($options{ib}) {
	require boring;
}
if($options{match}) {
	$options{match}=~s/[^\w\[\]\{\}\(\),:.+*?\\\$|-]//g; # sanitize
}

if(!defined $options{sort}){$options{sort}="-mtime";} # default sort by Time descending
if(!defined($options{hours}) || $options{hours}=~m/\D/) {$options{hours}=$defaulthoursfresh;}
my $hoursfresh=($options{hours}+0);
if($hoursfresh<1 || $hoursfresh>900) {$hoursfresh=$defaulthoursfresh}
my $maxage=3600*$hoursfresh;

my @list=();
my $now=time();
my $maxmtime=(stat($ENV{SCRIPT_FILENAME}))[9];
for my $r (<$resultdir/*.autoinst.txt>) {
	my @s=stat($r);
	my ($logsize,$mtime)=@s[7,9];
	if($mtime>$maxmtime){$maxmtime=$mtime}
	next if $mtime < $now - $maxage; # skip old
	next if($options{match} && $r!~m/$options{match}/);
	my ($distri, $type, $arch, $build, $extrainfo)=split_filename($r);
	my $testname = path_to_testname($r);

	my $backend_info;
	my $run_stat = {};

	my @lines=parse_log($r);
	my $parsed=parse_log_to_stats(\@lines);
	my $result=parse_log_to_hash(\@lines);
	my $running = 0;
	if($logsize==0) {
		# running
		my $running_basepath = running_log($testname);
		$backend_info = parse_log_json($running_basepath.'currentautoinst-log.txt');
		my $url=path_to_url($r);
		$run_stat = get_running_modinfo($running_basepath);
		$run_stat->{'run_backend'} = 0;
		if(-e "$running_basepath/os-autoinst.pid") {
			my $backpid = file_content("$running_basepath/os-autoinst.pid");
			chomp($backpid);
			$run_stat->{'run_backend'} = (-e "/proc/$backpid"); # kill 0 does not work with www user
		}
		$running = 1;
	}
	else {
		$backend_info = parse_log_json($r);
		if( open(FD, $r) ) {
			my $timeline = <FD>;
			chomp($timeline);
			if($timeline=~m/^\d+$/) {
				$mtime = $timeline;
			}
		}
		close(FD);
	}
	my $backend = $backend_info->{'backend'} || '';
	$backend =~s/^.*:://;
	if($options{ib}) {
		next if(boring::is_boring($r, $result));
	}
	if($options{ob}) {
		next if($options{ob} ne "" and $options{ob} ne $backend);
	}
	push(@list, {
		testname=>$testname, running=>$running, distri=>$distri, type=>$type, arch=>$arch,
		build=>$build, extrainfo=>$extrainfo, mtime=>$mtime, backend => $backend,
		res_ok=>$parsed->{OK}||0, res_unknown=>$parsed->{unknown}||0, res_fail=>$parsed->{fail}||0,
		res_overall=>$result->{overall}, run_stat=>$run_stat
		}
	);
}

my @sorted_list = sort_list(
	{running=>\&sort_num, build=>\&sort_num, mtime=>\&sort_num, res_ok=>\&sort_num, res_unknown=>\&sort_num, res_fail=>\&sort_num},
	sort_param_to_keys($options{sort}), \@list
);

my $mt = Text::MicroTemplate::Extended->new(
	include_path  => ['../htdocs/template'],
	template_args => { resultlist => \@sorted_list, options => \%options, hoursfresh=>$hoursfresh },
	macro => { sortarrows => sub { encoded_string(sortkeys(\%options, $_[0])); } },
);

foreach my $rundir (@runner) {
	my @s = stat($rundir.'/currentstep');
	my $mtime = $s[9];
	if($mtime>$maxmtime){$maxmtime=$mtime}
}

print header(-charset=>"UTF-8", -type=>"text/html", -Last_Modified=>awstandard::HTTPdate($maxmtime));
print $mt->render('currentresults');
